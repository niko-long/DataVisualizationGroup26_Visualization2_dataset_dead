{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../Flower.svelte",
    "../../SVGVisualOver.svelte",
    "../../SVGVisualBelow.svelte",
    "../../CanvasVisual.svelte",
    "../../CentralLineChart.svelte",
    "../../YearLabels.svelte",
    "../../Continents.svelte",
    "../../CountryHighlighter.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { csv } from 'd3-fetch';\n  import Flower from './flower/Flower.svelte';\n\n  const years = [2019, 2021, 2023];\n\n  let data;\n\n  async function load() {\n    data = await csv('deadOrders.csv', d => { // /childhood-mortality\n      //在public文件夹的文件好像可以直接引用?\n      const dataArr = [];\n      const dataArr2 = [];\n      const returnObj = {\n        //iso: d.iso,\n        //country: d.country,\n       //reduction: +d.reduction, //+号可以将csv的字符串形式的文件转换成数字类型\n        //continent: d.continent,\n        Territory: d.Territory,\n        CartPriceInCP: +d.CartPriceInCP, // 将csv字符串的形式的文件转换成数字类型\n        DeliveryTimeCost:+d.DeliveryTimeCost,\n        AveSpending: +d.AveSpending,\n        AccountNum: +d.AccountNum,\n        Area: d.Area,\n        Product:d.Product,\n        Quantities:+d.Quantities\n      };\n\n      for (let key in d) {\n        // 匹配列名，例如 'CartPriceInCP_2019'\n        let match = key.match(/^CartPriceInCP_(\\d{4})$/);\n        if (match) {\n          let year = +match[1]; // 提取年份\n          dataArr.push({\n            year: year,\n            value: +d[key]\n          });\n        }\n      }\n\n\n      for (let key in d) {\n        // 匹配列名，例如 'DeliveryTimeCost_2019'\n        let match = key.match(/^DeliveryTimeCost_(\\d{4})$/);\n        if (match) {\n          let year = +match[1]; // 提取年份\n          dataArr2.push({\n            year: year,\n            value: +d[key]\n          });\n        }\n      }\n\n      returnObj['dataArr'] = dataArr;\n      returnObj['dataArr2'] = dataArr2;\n      return returnObj;\n    });\n  }\n\n  load();//调用 load() 函数，启动了加载数据的过程。\n</script>\n\n<div class=\"wrapper\">\n  <div class=\"header\">\n    <h1>The Sales of Different Area</h1>\n  </div>\n  <div id=\"visual\">\n    {#if data}\n      <Flower {data} {years} /> \n      <!-- 这里是判断语句 如果有数据则渲染Flower-->\n    {/if}\n  </div>\n</div>\n\n<style>\n  .wrapper {\n    width: 95%;\n    height: 100%;\n    margin: 0 auto;\n  }\n\n  .header {\n    width: 100%;\n    margin: 1.5rem 0;\n    color: var(--medieval-yellow);\n  }\n\n  .header h1 {\n    font-family: 'MedievalSharp', serif;\n    font-weight: normal;\n    font-size: calc(6rem + 7px);\n    text-align: center;\n  }\n\n  #visual {\n    position: relative;\n    width: 100%;\n    height: 100vmin;\n  }\n</style>\n",
    "<script>\n  import { range, max, extent } from 'd3-array';\n  import { scaleLinear, scaleOrdinal } from 'd3-scale';\n\n  import CanvasVisual from './CanvasVisual.svelte';\n  import SVGVisualBelow from './SVGVisualBelow.svelte';\n  import SVGVisualOver from './SVGVisualOver.svelte';\n\n\n  export let data;\n  export let years;\n\n  const offset = 10;\n  const angleOffset = 0;\n\n  let selectedIso;\n  // 用于存储选定ISO编码的变量 \n\n  // Dimensions\n  let rawWidth = offset;\n  let rawHeight = offset;\n  // 这两行定义了一些变量 用于存储图形的原始宽度和高度。\n\n  // Scales\n  let scYearColor, scCountryAngle, scYearRadius, scMortRate, scCartPriceInCP, scDeliveryTimeCost;\n  //定义变量 用于D3存储比例尺\n\n  function initScales(minDim) {\n    scYearColor = scaleOrdinal()\n      .domain(years) // 设置了比例尺的 输入域为‘years’\n      .range(['rgb(252,123,35)', 'rgb(253, 203, 71)', 'rgb(176, 201, 73)']);//三个年份对应三种颜色\n\n    scCountryAngle = scaleOrdinal()\n      //.domain(data.map(d => d.iso))\n      .domain(data.map(d => d.Territory))\n      .range(range(angleOffset, 2 * Math.PI - angleOffset, (2 * Math.PI - 2 * angleOffset) / data.length));\n      // 这行代码将初始化另一个序数比例尺 通过将国家的iso编码映射到角度值 用于在极坐标中确定国家的位置 范围是0~2pi,最后一个是步长\n\n    //scYearRadius = scaleLinear()\n    scYearRadius = scaleLinear()\n      .domain([years[0], years[years.length-1]]) //分别是数据集中的第一个年份和最后一个年份\n      .range([minDim / 5, minDim / 2.4 - padding]);\n      //这段代码用于初始化一个线性比例尺 scYearRadius，该比例尺用于将年份映射到在可视化中表示年份的圆环的半径值。\n\n    scMortRate = scaleLinear()\n      .domain([0, 1.2 * max([].concat(...data.map(d => d.dataArr.filter(d => years.includes(d.year)).map(d => d.value))))])\n      .range([0, minDim / 9]);\n      // 创建一个关于Mortrate的比例尺 输入的范围是从0开始到最大死亡率的1.2倍\n      // data.map(d => ....)对数据进行集中处理 使用map遍历数据集中每个对象'd', 在每个对象中找到dataArr属性\n      // [].concat(...) is used to flatten the 数组 成一维数组\n      // max是找展平后的数组的最大值\n      \n\n    scCartPriceInCP = scaleLinear()\n      .domain(extent(data.map(d => d.CartPriceInCP)))\n      .range([Math.min(scYearRadius(years[years.length - 1]) + CartPriceInCPOffset, minDim / 2 - padding), minDim / 2 - padding]);\n      // 这里用来设置关于CartPriceInCP的比例尺 extent用来获取计算数组里的最小值和最大值\n      // 这里用了之前的scYearRadius来确定图片的圆形的尺寸 在这里应该是最外边的圆\n      //应该还没进入画圆的阶段\n\n    scDeliveryTimeCost = scaleLinear()\n      .domain(extent(data.map(d => d.DeliveryTimeCost)))\n      .range([Math.min(scYearRadius(years[years.length - 1]) + CartPriceInCPOffset, minDim / 2 - padding), minDim / 2 - padding]);\n      // 这里用来设置关于CartPriceInCP的比例尺 extent用来获取计算数组里的最小值和最大值\n      // 这里用了之前的scYearRadius来确定图片的圆形的尺寸 在这里应该是最外边的圆\n      //应该还没进入画圆的阶段\n  }\n\n  $: width = rawWidth - offset;\n  $: height = rawHeight - offset;\n  $: minDim = Math.min(width, height);\n  $: padding = minDim / 40;\n  $: CartPriceInCPOffset = minDim / 40;\n\n\n  $: if (data && years) initScales(minDim);\n  //$这里的是svelte中的响应式声明(Reactive declaration) 当所依赖的的变量改变时 表达式会被重新计算\n</script>\n\n<svelte:body on:click={() => selectedIso = undefined}/>\n<!--当用户点击页面时，将 selectedIso 变量设置为 undefined，用于取消当前的选择-->\n\n\n<div class=\"wrapper\" bind:offsetWidth={rawWidth} bind:offsetHeight={rawHeight}>\n  <!--这里的wrapper包裹了下面三个元素offsetWidth 和 offsetHeight 绑定在一起。\n    这样一来，当元素的宽度和高度发生变化时，rawWidth 和 rawHeight 也会相应地更新。\n  rawwidth以及rawHeight在上文中都等于offset 暂时设置了值为10-->\n  {#if (minDim > 0)}\n  <SVGVisualBelow width={width}\n                  height={height}\n                  offset={offset}\n                  data={data}\n                  years={years}\n                  scCountryAngle={scCountryAngle}\n                  scYearRadius={scYearRadius}\n                  scCartPriceInCP={scCartPriceInCP} />\n\n  <CanvasVisual width={width}\n              height={height}\n              offset={offset}\n              data={data}\n              years={years}\n              scYearColor={scYearColor}\n              scCountryAngle={scCountryAngle}\n              scYearRadius={scYearRadius}\n              scMortRate={scMortRate}\n              selectedIso={selectedIso} />\n  <SVGVisualOver width={width}\n                 height={height}\n                 offset={offset}\n                 data={data}\n                 years={years}\n                 scCountryAngle={scCountryAngle}\n                 scYearRadius={scYearRadius}\n                 scCartPriceInCP={scCartPriceInCP}\n                 scMortRate={scMortRate}\n                 selectedIso={selectedIso}\n                 on:isochanged={(e) => selectedIso = e.detail} />\n                 <!--事件监听器 事件发生后 显示详细信息-->\n  {/if}\n</div>\n\n<style>\n  .info {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    /*--当子元素的总宽度超过容器的宽度时 允许子元素换行显示 */\n    align-items: stretch;\n    justify-content: space-between;\n    /* 定义子元素在主轴上的对齐方式 space-between值使得主元素沿着主轴均匀分布*/\n    width: 100%;\n    /* 指定容器的宽度是父容器的100% */\n    height: auto;\n    /* 指定容器的高度根据内容自动调整*/\n    color: var(--sand);\n  }\n\n  .info > div {\n    width: 47%;\n    height: 100%;\n    margin-bottom: 0;\n  }\n\n  @media (max-width: 600px) {\n    .info > div {\n      width: 100%;\n      margin-bottom: 1.5rem;\n    }\n  }\n  /* display: flex;：指定了容器使用 Flex 布局。\n  Flex 布局是一种灵活的布局模式，能够使子元素在容器内动态排列，\n  并根据需要自动调整它们的大小。*/\n\n  .intro {\n    display: flex;\n    flex-direction: column;\n  }\n\n  .text {\n    text-align: justify;\n    line-height: 1.7;\n  }\n\n  .search {\n    display: flex;\n    flex-direction: column;\n    margin: 2rem 0 0 0;\n  }\n\n  .search.small {\n    align-items: center;\n  }\n  \n  .data-info {\n    font-size: 0.9rem;\n    font-style: italic;\n    line-height: 1.7;\n  }\n\n  .imprint {\n    display: flex;\n    margin: 1rem 0;\n    align-items: center;\n    font-size: 0.7rem;\n  }\n\n  .imprint img {\n    width: 1.7rem;\n    margin: 0 0.6rem 0 0;\n  }\n\n  .wrapper {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n",
    "<script>\n  import Defs from './Defs.svelte';\n  import YearLabels from './YearLabels.svelte';\n  import CentralLineChart from './CentralLineChart.svelte';\n  import CountryLabels from './CountryLabels.svelte';\n  import CountryHighlighter from './CountryHighlighter.svelte';\n  import IsoDetector from './IsoDetector.svelte';\n\n  export let width;\n  export let height;\n  export let offset;\n  export let data;\n  export let years;\n  export let scCountryAngle;\n  export let scYearRadius;\n  export let scCartPriceInCP;\n  export let scMortRate;\n  export let selectedIso;\n\n  $: innerRadius = scYearRadius(years[0]) * 0.62;\n  $: countryRadius = scCartPriceInCP.range()[1];\n</script>\n\n<svg class=\"svg-visual\"\n     width={width}\n     height={height}\n     style=\"margin: {offset / 2}px;\">\n  <Defs scCartPriceInCP={scCartPriceInCP} />\n  <YearLabels width={width}\n              height={height}\n              years={years}\n              scYearRadius={scYearRadius} />\n  <CentralLineChart width={width}\n                    height={height}\n                    data={data}\n                    selectedIso={selectedIso}\n                    radius={innerRadius} />\n  <CountryLabels width={width}\n                 height={height}\n                 data={data.map(d => ({Territory: d.Territory, Territory: d.Territory}))}\n                 scCountryAngle={scCountryAngle}\n                 radius={countryRadius}\n                 selectedIso={selectedIso} />\n  <CountryHighlighter width={width}\n                      height={height}\n                      data={data}\n                      years={years}\n                      scCountryAngle={scCountryAngle}\n                      scYearRadius={scYearRadius}\n                      scMortRate={scMortRate}\n                      scCartPriceInCP={scCartPriceInCP}\n                      selectedIso={selectedIso} />\n  <IsoDetector width={width}\n               height={height}\n               radius={scCartPriceInCP.range()[1]}\n               scCountryAngle={scCountryAngle}\n               selectedIso={selectedIso}\n               on:isochanged />\n</svg>\n\n<style>\n  svg {\n    position: absolute;\n\n  }\n</style>\n",
    "<script>\n  import Defs from './Defs.svelte';\n  import Continents from './Continents.svelte';\n  import CartPriceInCPPath from './CartPriceInCP.svelte';\n\n  export let width;\n  export let height;\n  export let offset;\n  export let data;\n  export let years;\n  export let scCountryAngle;\n  export let scYearRadius;\n  export let scCartPriceInCP;\n  export let scDeliveryTimeCost;\n  console.log('scDeliveryTimeCost:', scDeliveryTimeCost);\n\n  let areasData;\n\n  function loadAreasData() {\n    const uniqueAreas = [...new Set(data.map(d => d.Area))];\n    // data.map(d => d.area) 获取数据集中所有area的列表\n    // [...new Set()] 去除了重复的area名称，保留了唯一的area列表。\n    //通过 map 方法遍历唯一的area列表，对每个area进行处理，\n    //生成一个包含每个area起始角度、结束角度和area名称的对象。\n    areasData = uniqueAreas.map(Area => {\n      const raw = data.map(d => d.Area);\n      //首先，通过 data.map(d => d.Area) 获取数据集中所有大陆的列表，\n      //存储在 raw 变量中。\n      return {\n        startAngle: scCountryAngle(data[raw.indexOf(Area)].Territory),\n        //然后，通过 indexOf() 方法获取当前大陆在 raw 列表中第一次出现的索引，\n        //并通过 lastIndexOf() 方法获取当前大陆在 raw 列表中最后一次出现的索引\n        endAngle: scCountryAngle(data[raw.lastIndexOf(Area)].Territory),\n        //使用这两个索引分别获取对应大陆的 ISO 编码，\n        //并将 ISO 编码传递给 scCountryAngle() 函数，以获取该国家在极坐标中的角度\n        //将获取到的起始角度和结束角度分别存储到 startAngle 和 endAngle 属性中。\n        Area\n        //在 map 方法中遍历唯一的大陆列表，对每个大陆执行以下操作：\n        //首先，通过 data.map(d => d.continent) 获取数据集中所有大陆的列表，\n        //并找到当前大陆在列表中第一次出现的索引和最后一次出现的索引，\n        //分别使用 indexOf() 和 lastIndexOf() 方法\n      };\n    });\n  }\n\n  // Prepare data for continent labels\n  $: if (data) loadAreasData();\n  //这段代码是 Svelte 中的响应式声明（Reactive declaration）。\n  //当 data 变量的值改变时，将触发 loadContinentsData() 函数的执行。\n</script>\n\n<svg class=\"svg-visual\"\n     width={width}\n     height={height}\n     style=\"margin: {offset / 2}px;\">\n  <!--<Defs scCartPriceInCP={scCartPriceInCP} />-->\n  <CartPriceInCPPath width={width}\n                 height={height}\n                 data={data}\n                 scCountryAngle={scCountryAngle}\n                 scCartPriceInCP={scCartPriceInCP}\n                 scDeliveryTimeCost={scDeliveryTimeCost} />\n  <Continents width={width}\n              height={height}\n              data={areasData}\n              years={years}\n              scYearRadius={scYearRadius} />\n</svg>\n\n<style>\n  svg {\n    position: absolute;\n    \n  }\n</style>\n",
    "<script>\n  import { onMount } from 'svelte';\n\n  export let width;\n  export let height;\n  export let offset;\n  export let data;\n  export let years;\n  export let scYearColor;\n  export let scCountryAngle;\n  export let scYearRadius;\n  export let scMortRate;\n  export let selectedIso;\n\n  const canvasScaleFactor = 2;\n\n  // Elements\n  let canvas, ctx;\n\n  function init() {\n    canvas.width = canvasScaleFactor * width;\n    //设置 Canvas 元素的宽度和高度为原始宽度和高度\n    //乘以缩放比例 canvasScaleFactor，以实现高分辨率绘图。\n    canvas.height = canvasScaleFactor * height;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    //设置 Canvas 元素的样式宽度和高度为原始宽度和高度，以确保 Canvas 在页面上显示的大小和原始大小一致。\n    canvas.style.margin = `${offset / 2}px`;\n\n    ctx.scale(canvasScaleFactor, canvasScaleFactor);\n    ctx.translate(width / 2, height / 2);\n    //将绘图原点移动到 Canvas 元素的中心，以便后续的绘图操作基于 Canvas 元素的中心进行。\n\n    ctx.globalCompositeOperation = 'luminosity';\n    //设置绘图上下文的全局合成操作为 'luminosity'，这会使绘制的图形与已存在的图形进行混合，\n    //具体效果根据所绘制图形和背景图形的亮度进行计算。\n  }\n\n  function drawSword(x, y, r) {\n    ctx.beginPath();\n\n    const handleWidth = r * 0.2; // Adjust handle width as needed\n    const handleHeight = r * 0.4; // Adjust handle height as needed\n    const bladeLength = r * 1.2; // Adjust blade length as needed\n    const bladeWidth = r * 0.3; // Adjust blade width as needed\n\n    // Handle top left\n    ctx.moveTo(x - handleWidth / 2, y);\n\n    // Handle bottom left\n    ctx.lineTo(x - handleWidth / 2, y + handleHeight);\n\n    // Blade bottom left\n    ctx.lineTo(x - bladeWidth / 2, y + handleHeight + bladeLength * 0.2);\n\n    // Blade bottom right\n    ctx.lineTo(x + bladeWidth / 2, y + handleHeight + bladeLength * 0.2);\n\n    // Blade top right\n    ctx.lineTo(x + bladeWidth / 2, y + handleHeight + bladeLength);\n\n    // Blade tip (adjust for a sharper point)\n    ctx.lineTo(x, y + handleHeight + bladeLength + r * 0.1);\n\n    // Handle top right\n    ctx.lineTo(x + handleWidth / 2, y + handleHeight);\n\n    // Handle top left (close the path)\n    ctx.lineTo(x - handleWidth / 2, y);\n\n    ctx.closePath();\n    ctx.fillStyle = scYearColor(years);\n    ctx.fill();\n  }\n  function drawShield(x, y, r) {\n  ctx.beginPath();\n\n  const notchRatio = 0.25; // Adjust notch ratio for shield indentation\n  const notchDepth = r * notchRatio; // Notch depth based on radius\n  const handleWidth = r * 0.15; // Adjust handle width\n  const handleLength = r * 0.3; // Adjust handle length\n\n  // Left side with notch\n  ctx.moveTo(x - r, y);\n  ctx.lineTo(x - r + notchDepth, y + notchDepth);\n  ctx.lineTo(x - r + notchDepth, y + r - notchDepth);\n\n  // Top curve\n  const numPointsTop = 15; // Adjust for smoothness\n  const angleStepTop = Math.PI / numPointsTop;\n  for (let i = 0; i <= numPointsTop; i++) {\n    const angle = i * angleStepTop;\n    const bulge = Math.sin(angle) * r * 0.1; // Adjust bulge amount\n    const cx = x - r + notchDepth + (r - 2 * notchDepth) * Math.cos(angle) + bulge;\n    const cy = y + r - notchDepth - (r - 2 * notchDepth) * Math.sin(angle);\n    if (i === 0) {\n      ctx.lineTo(cx, cy);\n    } else {\n      ctx.lineTo(cx, cy);\n    }\n  }\n\n  // Right side\n  ctx.lineTo(x + r, y + notchDepth);\n  ctx.lineTo(x + r, y);\n\n  // Handle base\n  ctx.lineTo(x + r - handleWidth / 2, y + handleLength);\n\n  // Handle curve\n  ctx.quadraticCurveTo(x, y + handleLength * 1.2, x - handleWidth / 2, y);\n\n  ctx.closePath();\n  ctx.fillStyle = scYearColor(years);\n  ctx.fill();\n}\n\nfunction drawStar(ctx, x, y, radius, numPoints, innerRadius) {\n    ctx.beginPath();\n    for (let i = 0; i < 2 * numPoints; i++) {\n        const r = i % 2 === 0 ? radius : innerRadius;\n        const angle = (i * Math.PI) / numPoints;\n        const xPos = x + Math.cos(angle) * r;\n        const yPos = y + Math.sin(angle) * r;\n        if (i === 0) {\n            ctx.moveTo(xPos, yPos);\n        } else {\n            ctx.lineTo(xPos, yPos);\n        }\n    }\n    ctx.closePath();\n    ctx.fill();\n}\n\n\n\n\n  function draw(width, height, selectedIso) {\n    ctx.clearRect(-width / 2, -height / 2, width, height);\n    //这行代码用于清除 canvas 上的内容，以便重新绘制新的图形。\n    //它使用 clearRect 方法清除一个矩形区域，\n    //矩形的左上角位于 (-width / 2, -height / 2)，宽度为 width，高度为 height。\n    ctx.globalAlpha = selectedIso ? 0.1 : 0.4;\n    //这行代码根据 selectedIso 变量的值设置绘制的图形的不透明度。\n    //如果 selectedIso 为真，则不透明度为 0.1，否则为 0.4。\n\n\n\n    years.forEach(year => {\n      ctx.fillStyle = scYearColor(year);\n      data.forEach(d => {\n        const yearData = d.dataArr.find(d => d.year === year);\n        const x = Math.sin(Math.PI - scCountryAngle(d.Territory)) * scYearRadius(year);\n        const y = Math.cos(Math.PI - scCountryAngle(d.Territory)) * scYearRadius(year);\n        ctx.beginPath();\n        //ctx.arc(x, y, scMortRate(yearData.value)*0.3, 0, 2 * Math.PI);\n        drawStar(ctx,x, y,scMortRate(yearData.value) * 0.45,15,scMortRate(yearData.value) * 0.1); // Adjust radius as needed\n\n        //在给定的坐标 (x, y) 处绘制一个圆弧，2*pi就是一整个圆形\n        //圆心坐标为 (x, y)，半径由 scMortRate 函数根据数据值确定。\n        ctx.fill();\n      });\n    });\n  }\n\n  onMount(() => {\n    ctx = canvas.getContext('2d');\n  });\n  //这行代码在组件挂载到 DOM 上后立即执行。在这个函数内部，\n  //它获取了 canvas 的 2D 渲染上下文（getContext('2d')），并将其赋值给了 ctx 变量。\n\n  $: if (ctx) init(width, height);\n  //这是一个响应式声明，它会在依赖的变量发生变化时重新运行。这里，它检查 ctx 是否存在，\n  //如果存在，则调用 init 函数来初始化 canvas 的宽度、高度等参数\n\n\n  $: if (ctx && data) draw(width, height, selectedIso);\n  //同样是一个响应式声明，它在 ctx 和 data 变化时重新运行。\n  //如果 ctx 和 data 都存在，它会调用 draw 函数来绘制图形。\n</script>\n\n<canvas class=\"canvas-visual\"\n        bind:this={canvas}></canvas>\n\n<style>\n  canvas {\n    position: absolute;\n  }\n</style>\n",
    "<script>\n  import { extent, max } from 'd3-array';\n  import { scaleLinear } from 'd3-scale';\n  import { line as d3line, curveCardinal } from 'd3-shape';\n\n  export let width;\n  export let height;\n  export let data;\n  export let selectedIso;\n  export let radius;\n\n  let dataArr,dataArr2, xScale,xScale2, yScale,yScale2, line,line2, yLabels,yLabels2,yLabels3;\n  let Territory, CartPriceInCP, AccountNum, Area, Product,Quantities;\n  function updateScalesAndGenerators(radius) {\n\n    xScale = scaleLinear()\n      .domain(extent([].concat(...data.map(d => d.dataArr)).map(d => d.year)))\n      .range([-radius / 1.5, radius / 1.5]);\n\n    yScale = scaleLinear()\n      .domain([-10, max([].concat(...data.map(d => d.dataArr)).map(d => d.value))])\n      .range([radius / 2, -radius / 2]);\n      \n    line = d3line()\n      .x(d => xScale(d.year))\n      .y(d => yScale(d.value))\n      .curve(curveCardinal);\n\n    yLabels = [\n      {\n        x: xScale(dataArr[0].year) * 1.05,\n        y: yScale(dataArr[0].value) + Math.min(width, height) / 200,\n        text: Math.round(dataArr[0].value),\n        textAnchor: 'end'\n      },\n      {\n        x: xScale(dataArr[dataArr.length - 1].year) * 1.05,\n        y: yScale(dataArr[dataArr.length - 1].value) + Math.min(width, height) / 200,\n        text: Math.round(dataArr[dataArr.length - 1].value),\n        textAnchor: 'start'\n      }\n    ];\n  }\n\n  function updateScalesAndGenerators2(radius) {\n\n    xScale2 = scaleLinear()\n      .domain(extent([].concat(...data.map(d => d.dataArr2)).map(d => d.year)))\n      .range([-radius / 1.5, radius / 1.5]);\n\n    yScale2 = scaleLinear()\n      .domain([-10, max([].concat(...data.map(d => d.dataArr2)).map(d => d.value))])\n      .range([radius / 2, -radius / 2]);\n      \n    line2 = d3line()\n      .x(d => xScale2(d.year))\n      .y(d => yScale2(d.value))\n      .curve(curveCardinal);\n    \n    \n\n    yLabels2 = [\n      {\n        x: xScale2(dataArr2[0].year) * 1.05,\n        y: yScale2(dataArr2[0].value) + Math.min(width, height) / 200,\n        text: Math.round(dataArr2[0].value),\n        textAnchor: 'end'\n      },\n      {\n        x: xScale2(dataArr2[Math.floor((dataArr2.length+1) / 2)].year) * 0.55,\n        y: yScale2(dataArr2[Math.floor((dataArr2.length+1) / 2)].value+20) + Math.min(width, height) / 200,\n        text: Math.round(dataArr2[Math.floor(dataArr2.length / 2)].value),\n        textAnchor: 'middle'  // Adjust as needed\n      },\n      {\n        x: xScale2(dataArr2[dataArr2.length - 1].year) * 1.05,\n        y: yScale2(dataArr2[dataArr2.length - 1].value) + Math.min(width, height) / 200,\n        text: Math.round(dataArr2[dataArr2.length - 1].value),\n        textAnchor: 'start'\n      }\n    ];\n\n\n    const selectedData = data.find(d => d.Territory === selectedIso);\n\n    if (selectedData) {\n      CartPriceInCP = selectedData.CartPriceInCP;\n      AccountNum = selectedData.AccountNum;\n      Area = selectedData.Area;\n      Product = selectedData.Product;\n      Quantities = selectedData.Quantities;\n      Territory = selectedData.Territory;\n\n      console.log('CartPriceInCP:', CartPriceInCP); // Debug: Check each value\n      console.log('AccountNum:', AccountNum);\n      console.log('Area:', Area);\n      console.log('Product:', Product);\n    } else {\n      CartPriceInCP = AccountNum = Area = Product = undefined;\n    };\n  }\n\n  $: if (data && selectedIso) dataArr = data.find(d => d.Territory === selectedIso).dataArr.filter(d => !isNaN(d.value));\n  $: if (data && selectedIso) dataArr2 = data.find(d => d.Territory === selectedIso).dataArr2.filter(d => !isNaN(d.value));\n\n  // 这里比较重要 过滤了没有数据的部分?\n  $: if (data && dataArr) updateScalesAndGenerators(radius);\n  $: if (data && dataArr2) updateScalesAndGenerators2(radius);\n</script>\n\n{#if (data && selectedIso)}\n<!--这里根据条件块来确定是否显示SVG元素 如果data和 selectediso都存在那么就渲染下面的内容-->\n  <g transform=\"translate({width / 2} {height / 2})\">\n    <circle cx=\"0\" cy=\"0\" r=\"240\" \n    stroke=\"#4682B4\"\n    stroke-width=15\n    stroke-dasharray=\"2,10\"\n    fill=\"white\"\n    fill-opacity=\"0.6\"></circle>\n    <text class=\"title\"\n          transform=\"translate(0 {yScale.range()[1] * 1.4})\">Sales Per Territory</text>\n    <text class=\"titlesmall\"\n          transform=\"translate(0 {yScale.range()[1] * 1.1})\">From 2019 to 2023</text>\n    <path d={line(dataArr)}\n          stroke=\"orange\"\n          stroke-width=\"5\"\n          fill=\"none\"></path>\n    {#each yLabels as yLabel}\n      <text class=\"y-label\"\n            transform=\"translate({yLabel.x} {yLabel.y})\"\n            text-anchor={yLabel.textAnchor}>{yLabel.text}</text>\n    {/each}\n    <text class=\"price-label\"\n    transform=\"translate({xScale.range()[1] * (-1.25)} {yScale.range()[1] * (0.15)})\">PriceInCP</text>\n    <line x1={xScale.range()[0]}\n          y1={yScale.range()[0]}\n          x2={xScale.range()[1]}\n          y2={yScale.range()[0]}></line>\n    {#each xScale.domain() as xLabel, i}\n      <text class=\"x-label\"\n            transform=\"translate({xScale(xLabel)} {yScale.range()[0] * 1.25})\"\n            text-anchor={i % 2 === 0 ? 'start' : 'end'}>{xLabel}</text>\n    {/each}\n  </g>\n{/if}\n\n{#if (data && selectedIso)}\n<!--这里是测试新加相关的delivery time的图--> \n<!--这里根据条件块来确定是否显示SVG元素 如果data和 selectediso都存在那么就渲染下面的内容-->\n  <g transform=\"translate({width / 1.2} {height / 4})\">\n    <circle cx=\"0\" cy=\"0\" r=\"260\" \n     stroke=\"#4682B4\"\n     stroke-width=20\n     stroke-dasharray=\"2,10\"\n     fill=\"white\"\n    fill-opacity=\"0.6\"></circle>\n    <text class=\"title2\"\n          transform=\"translate(0 {yScale2.range()[1] * 1.4})\">Delivery Time Cost</text>\n    <text class=\"titlesmall2\"\n          transform=\"translate(0 {yScale2.range()[1] * 1.1})\"> Per Territory</text>\n    <path d={line2(dataArr2)}\n          stroke=\"orange\"\n          stroke-width=\"5\"\n          fill=\"none\"></path>\n    {#each yLabels2 as yLabel}\n      <text class=\"y-label2\"\n            transform=\"translate({yLabel.x} {yLabel.y})\"\n            text-anchor={yLabel.textAnchor}>{yLabel.text}</text>\n    {/each}\n    <text class=\"price-label2\"\n    transform=\"translate({xScale.range()[1] * (-1.25)} {yScale.range()[1] * (0.15)})\">Days</text>\n    <line x1={xScale.range()[0]}\n          y1={yScale.range()[0]}\n          x2={xScale.range()[1]}\n          y2={yScale.range()[0]}></line>\n    {#each xScale.domain() as xLabel, i}\n      <text class=\"x-label2\"\n            transform=\"translate({xScale(xLabel)} {yScale.range()[0] * 1.25})\"\n            text-anchor={i % 2 === 0 ? 'start' : 'end'}>{xLabel}</text>\n    {/each}\n  </g>\n{/if}\n\n{#if (data && selectedIso)}\n  <image href=\"/HowToRead.png\" x=\"1\" y=\"200\" height=\"1000\" width=\"1000\"></image>\n\n<!--这里是测试新加相关的 仪表盘 风格信息 的图--> \n<!--这里根据条件块来确定是否显示SVG元素 如果data和 selectediso都存在那么就渲染下面的内容-->\n  <g transform=\"translate({width / 1.15} {height / 1.45})\">\n    <circle cx=\"0\" cy=\"0\" r=\"260\" \n     stroke=\"#4682B4\"\n     stroke-width=20\n     stroke-dasharray=\"2,10\"\n     fill=\"rgb(255,255,255)\"\n    fill-opacity=\"0.5\"></circle>\n    <text class=\"detailsLarge\" transform=\"translate({xScale.range()[1] * (-0.5)} {yScale2.range()[1] * 1.4})\">DETAILS</text>\n      {#if CartPriceInCP !== undefined && AccountNum !== undefined && Area !== undefined && Product !== undefined}\n      <text class=\"details\" transform=\"translate({xScale.range()[1] * (-1)} {yScale2.range()[1] * 0.7})\">Territory Name: {Territory}</text>\n      <text class=\"details\" transform=\"translate({xScale.range()[1] * (-1)} {yScale2.range()[1] * 0.3})\">Total Sales(InCP): {CartPriceInCP}</text>\n      <text class=\"details\" transform=\"translate({xScale.range()[1] * (-1)} {yScale2.range()[1] * -0.1})\">Costumer Number: {AccountNum}</text>\n      <text class=\"details\" transform=\"translate({xScale.range()[1] * (-1)} {yScale2.range()[1] * -0.5})\">Belong to Area: {Area}</text>\n      <text class=\"details\" transform=\"translate({xScale.range()[1] * (-1)} {yScale2.range()[1] * -0.9})\">TOP Product: {Product}</text>\n     {/if}\n\n  </g>\n{/if}\n\n<style>\n    @font-face {\n    font-family: 'digital-7';\n    src: url('/digital-7.ttf') format('truetype');\n    font-weight: normal;\n    font-style: normal;\n  }\n  @font-face {\n    font-family: 'advanced_dot_digital-7';\n    src: url('/advanced_dot_digital-7.ttf') format('truetype');\n    font-weight: normal;\n    font-style: normal;\n  }\n  text.title {\n    font-size: calc(1.2rem + 0.5vmin);\n    text-anchor: middle;\n    fill: #103074;\n  }\n  text.titlesmall {\n    font-size: calc(0.8rem + 0.5vmin);\n    text-anchor: middle;\n    fill: #103074;\n  }\n  text.price-label {\n    font-size: 1rem;\n    text-anchor: middle;\n    fill: #103074;\n  }\n\n  text.y-label {\n    font-size: 1rem;\n    fill: #103074;\n  }\n  \n  text.x-label {\n    font-size: 1rem;\n    fill: #103074;\n  }\n    text.title2 {\n    font-size: calc(1.2rem + 0.5vmin);\n    text-anchor: middle;\n    fill: rgb(0, 44, 97);\n  }\n  text.titlesmall2 {\n    font-size: calc(0.8rem + 0.5vmin);\n    text-anchor: middle;\n    fill: #103074;\n  }\n  text.price-label2 {\n    font-size: 1.5rem;\n    text-anchor: middle;\n    fill: rgb(0, 44, 97);\n  }\n\n  text.y-label2 {\n    font-size: 1.5rem;\n    fill: rgb(0, 44, 97);\n  }\n  \n  line {\n    stroke: rgb(0, 44, 97);\n    stroke-width: 4;\n  }\n\n  text.x-label2 {\n    font-size: 1.5rem;\n    fill: rgb(0, 44, 97);\n  }\n  text.detailsLarge {\n    font-family: 'digital-7',monospace;\n    font-size: 2rem;\n    fill: #051842;\n  }\n  text.details {\n    font-family: 'digital-7';\n    font-size: 1.5rem;\n    fill: #103074;\n  }\n\n</style>\n",
    "<script>\n  export let width;\n  export let height;\n  export let years;\n  export let scYearRadius;\n</script>\n\n<g transform=\"translate({width / 2} {height / 2})\">\n  {#each years as year}\n    <text transform=\"translate(0 {-scYearRadius(year) + Math.min(width, height) / 40})\">{year}</text>\n  {/each}\n</g>\n\n<style>\n  text {\n    fill: #103074;\n    font-size: 1.5rem;\n    text-anchor: middle;\n  }\n</style>\n",
    "<script>\n  import { arc as d3arc } from 'd3-shape';\n\n  export let width;\n  export let height;\n  export let data;\n  export let years;\n  export let scYearRadius;\n\n  const shrinkFactor = 0.70;\n  const lineThicknessFactor = 1.05;\n  const labelOffsetFactor = 1.1;\n\n  let arc, labelArc;\n\n  // The arcs\n  function defineArcs() {\n    console.log(data);//检查数据\n    //const innerAreaRadius = scYearRadius(years[0]) * shrinkFactor;\n    const innerAreaRadius = scYearRadius(years[0]) * shrinkFactor;\n    arc = d3arc()\n      .startAngle(d => d.startAngle)\n      .endAngle(d => d.endAngle)\n      .innerRadius(innerAreaRadius)\n      .outerRadius(innerAreaRadius * lineThicknessFactor)\n      .cornerRadius(7);\n\n    labelArc = d3arc()\n      .startAngle(d => d.startAngle)\n      .endAngle(d => d.endAngle)\n      .innerRadius(innerAreaRadius * labelOffsetFactor)\n      .outerRadius(innerAreaRadius * labelOffsetFactor);\n  }\n\n  $: if (scYearRadius) defineArcs();\n</script>\n\n{#if data}\n  <g transform=\"translate({width / 2} {height / 2})\">\n    {#each data as d}\n      <path class=\"Area-arc\" d={arc(d)}></path>\n      <path class=\"Area-label-arc\" id=\"Area-label-arc-{d.Area}\" d={labelArc(d)}></path>\n      <text>\n        <textPath class=\"Area-label\" href=\"#Area-label-arc-{d.Area}\" startOffset=\"25%\">\n          {d.Area}\n        </textPath>\n      </text>\n    {/each}\n  </g>\n{/if}\n\n<style>\n  path.Area-arc {\n    stroke-dasharray: 1, 1;\n    fill: var(--areaColor);\n  }\n  path.Area-label-arc {\n    fill: none;\n  }\n\n  textPath.Area-label {\n    fill: #063102;\n    text-anchor: middle;\n    font-family: MedievalSharp, sans-serif; \n    /*--MedievalSharp 是首选字体。如果用户的设备上安装了这个字体，将会使用它。\nsans-serif 是备选字体。如果用户的设备上没有安装 MedievalSharp，浏览器会使用系统默认的 sans-serif 字体。*/\n    font-size: 1.8rem;\n  }\n</style>\n",
    "<script>\n  import { select } from 'd3-selection';\n  import { transition } from 'd3-transition';\n\n  export let width;\n  export let height;\n  export let data;\n  export let years;\n  export let scCountryAngle;\n  export let scYearRadius;\n  export let scMortRate;\n  export let scCartPriceInCP;\n  export let selectedIso;\n\n  let CartPriceInCP;\n  let container;\n  let modelYears, modelCartPriceInCP;\n\n  function update(selectedIso) {\n    if (!selectedIso) {\n      modelYears = [];\n      CartPriceInCP = 0;\n      modelCartPriceInCP = [];\n    } else {\n      CartPriceInCP = data.find(d => d.Territory === selectedIso).CartPriceInCP;\n      modelCartPriceInCP = [{\n        cx: Math.sin(Math.PI - scCountryAngle(selectedIso)) * scCartPriceInCP(CartPriceInCP) * (CartPriceInCP <= 0 ? 0.97 : 1.03),\n        //根据CartPriceInCP的值来确定CartPriceInCP的指示圈的位置是在内还是在外\n        cy: Math.cos(Math.PI - scCountryAngle(selectedIso)) * scCartPriceInCP(CartPriceInCP) * (CartPriceInCP <= 0 ? 0.97 : 1.03),\n        r: Math.min(width, height) / 200\n        \n      }];\n      modelYears = data.find(d => d.Territory === selectedIso).dataArr.filter(d => years.includes(d.year)) || [];\n      // 这里||是或逻辑运算符。如果没有找到与当前选定的ISO国家相匹配的的数据对象,或者筛选后的数据为空,就将‘modelYears’设置为空数组‘[]’\n\n    }\n\n    // the three year highlighters\n    select(container).selectAll('.year-circle')\n      .data(modelYears)\n      .join(enter => enter.append('circle')\n                      .attr('class', 'year-circle')\n                      .attr('fill', 'orange')\n                      .attr('opacity', 0.6)\n                      .attr('cx', 0)\n                      .attr('cy', 0)\n                      .attr('r', 0)\n                      //初始时不显示\n                      .call(enter => enter.transition().duration(100)\n                      //对于新圈的元素 调用‘transition‘方法来创建一个过渡效果 持续时间为100ms\n                        .attr('cx', d => Math.sin(Math.PI - scCountryAngle(selectedIso)) * scYearRadius(d.year))\n                        .attr('cy', d => Math.cos(Math.PI - scCountryAngle(selectedIso)) * scYearRadius(d.year))\n                        .attr('r', d => scMortRate(d.value))),\n            update => update.transition().duration(100)\n            //处理更新状态\n                        .attr('cx', d => Math.sin(Math.PI - scCountryAngle(selectedIso)) * scYearRadius(d.year))\n                        .attr('cy', d => Math.cos(Math.PI - scCountryAngle(selectedIso)) * scYearRadius(d.year))\n                        .attr('r', d => scMortRate(d.value)),\n            exit => exit.transition().duration(100)\n            //退出状态\n                      .attr('cx', 0)\n                      .attr('cy', 0)\n                      .attr('r', 0)\n                      .remove()\n      );\n\n    // the CartPriceInCP highlighter\n    select(container).selectAll('.CartPriceInCP-circle')\n      .data(modelCartPriceInCP)\n      .join(enter => enter.append('circle')\n                      .attr('class', `CartPriceInCP-circle ${CartPriceInCP <= 0 ? 'decreased' : 'increased'}`)\n                      // 根据减少率的正负值 为每个圆圈元素添加不同的类名 用于后续的样式设置\n                      .attr('cx', 0)\n                      .attr('cy', 0)\n                      .attr('r', 0)\n                      .call(enter => enter.transition().duration(100)\n                        .attr('cx', d => d.cx)\n                        .attr('cy', d => d.cy)\n                        .attr('r', d => d.r)),\n            update => update\n                        .attr('class', `CartPriceInCP-circle ${CartPriceInCP <= 0 ? 'decreased' : 'increased'}`)\n                        .transition().duration(100)\n                          .attr('cx', d => d.cx)\n                          .attr('cy', d => d.cy)\n                          .attr('r', d => d.r),\n            exit => exit.transition().duration(100)\n                      .attr('cx', 0)\n                      .attr('cy', 0)\n                      .attr('r', 0)\n                      .remove()\n      );\n  }\n\n  $: if (container) update(selectedIso);\n</script>\n\n<g transform=\"translate({width / 2} {height / 2})\" bind:this={container}></g>\n\n<style>\n  :global(circle.increased) {\n    opacity: 1;\n    fill: rgb(70, 130, 180);\n  }\n/* 这里将增加的死亡率用红色显示 透明度完全不透明*/\n\n  :global(circle.decreased) {\n    opacity: 1;\n    fill: rgb(70, 130, 180);\n  }\n</style>\n"
  ],
  "names": [],
  "mappings": "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"
}